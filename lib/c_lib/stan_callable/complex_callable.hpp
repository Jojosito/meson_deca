#ifndef STAN__EXTERNAL__LIB__C_LIB__STAN_CALLABLE__COMPLEX_CALLABLE_HPP
#define STAN__EXTERNAL__LIB__C_LIB__STAN_CALLABLE__COMPLEX_CALLABLE_HPP

#include <stan/math/prim/mat/fun/Eigen.hpp>
//#include <stan/meta/traits.hpp> //stan::return_type
//#include <stan/math/error_handling/matrix/check_size_match.hpp>
#include <vector>

// Deprecated, but may be still useful for debugging. Implements
// similar functions as in meson_deca/lib/c_lib/complex, but these
// functions may be called directly from STAN. To do so, one has to:
// - put everything into correct namespace;
// - update STAN register, manually or using meson_deca/install_lib.sh


namespace stan {
  namespace math { 


    /**
     * vector c_complex(scalar, scalar)
     *
     * Complex number constructor.
     * Takes two scalars a,b returns the vector (a, b).
     *
     * @tparam T0, T1 Scalar argument types
     * @tparam T2 Scalar return type
     */
    template <typename T0, typename T1>
    inline
    std::vector<typename boost::math::tools::promote_args<T0, T1>::type>
    c_complex(const T0& re, const T1& im) {

        typedef typename boost::math::tools::promote_args<T0, T1>::type T2;
        std::vector<T2> res(2);
        res[0] = re;
        res[1] = im;

        return stan::math::promote_scalar<T2>(res);
    }


    /**
     * vector c_mult(vector, vector)
     *
     * Complex number multiplication (each number is represented by a vector).
     *
     * @tparam T0, T1 scalar types of input vectors
     */
    template <typename T0, typename T1>
    inline
    std::vector<typename boost::math::tools::promote_args<T0, T1>::type>
    c_mult(const std::vector<T0> &v1,
           const std::vector<T1> &v2) {

        typedef typename boost::math::tools::promote_args<T0, T1>::type T2;
        std::vector<T2> res(2);
        res[0] = v1[0] * v2[0] - v1[1] * v2[1];
        res[1] = v1[0] * v2[1] + v1[1] * v2[0];
        return stan::math::promote_scalar<T2>(res);
    }


    /**
     * vector c_one(scalar)
     *
     * Complex number 1.
     * Takes a real number and returns the vector (1., 0.).
     *
     * Generated using STAN model generator.
     */
    template <typename T0>
    inline
    std::vector<typename boost::math::tools::promote_args<T0>::type>
        c_one(const T0 &y) {
        typedef typename boost::math::tools::promote_args<T0>::type T2;
        std::vector<T2> res(2);
        res[0] = 1.0;
        res[1] = 0.0;
        return stan::math::promote_scalar<T2>(res);
    }


    /**
     * real c_sq_mag(vector)
     *
     * Square magnitude of a complex number.
     * Takes the vector (a, b), returns a**2 + b**2.
     *
     * Generated using STAN model generator.
     */
    template <typename T0>
    inline
    typename boost::math::tools::promote_args<T0>::type
    c_sq_mag(const std::vector<T0> &v) {
        typedef typename boost::math::tools::promote_args<T0>::type T2;
        return stan::math::promote_scalar<T2>(v[0] * v[0] + v[1] * v[1]);
    }


    /**
     * c_vector cv_mult(c_vector, c_vector)
     *
     * Multiplication of two complex vectors (represented by an array
     * (std::vector) with two elements - 1st element of the array is the real
     * part of the complex vector, 2nd element is the imag. part of the vector).
     *
     * P.S. This function is partly generated by STAN and adapted by yours
     * truly. Alter with caution.
     *
     * @tparam T0, T1 scalar types of input complex vectors
     */

    template <typename T0__, typename T1__>
    inline
    std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,1> >
    cv_mult(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& v1,
        const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& v2) {
        typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
        typedef fun_scalar_t__ fun_return_scalar_t__;

        vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > res(2, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (v1[0].rows())));
        for (int i = 0; i < v1[0].rows(); i++) {
            res[0](i) = v1[0](i) * v2[0](i) - v1[1](i) * v2[1](i);
            res[1](i) = v1[0](i) * v2[1](i) + v1[1](i) * v2[0](i);
        }

        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
    }



    /**
     * vector cv_sum(matrix)
     *
     * Sum of a complex vector (represented by an array with
     * two elements - 1st element is the real part of the complex vector, 
     * 2nd element is the imag. part of the vector).
     *
     * @tparam T0 Scalar matrix type
     */
    template <typename T0__>
    inline
    std::vector<typename boost::math::tools::promote_args<T0__>::type>
    cv_sum(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& v1) {
        typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
        typedef fun_scalar_t__ fun_return_scalar_t__;

        vector<fun_scalar_t__> res(2);
        res[0] = 0.0;
        res[1] = 0.0;

        for (int i = 0; i < v1[0].rows(); i++) {
            res[0] += v1[0](i);
            res[1] += v1[1](i);
        }

        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
    }

  }
}
#endif
